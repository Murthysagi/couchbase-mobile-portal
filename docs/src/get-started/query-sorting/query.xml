<?xml version="1.0" encoding="UTF-8"?>
<article xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../../../docs.xsd" id="query">
    <title>Query</title>
    <description>This guide shows you how to query indexes built with MapReduce.</description>
    <introduction>
        <paragraph>
            This is the main reason why you are reading this guide. Here you will learn how to run queries over the indexes you have built with MapReduce.
        </paragraph>
    </introduction>
    <topics>
        <topic id="query">
            <title>How to Query</title>
            <body>
                <paragraph>A View is of course useless if you can't query it. Here's how it works in its simplest form:</paragraph>
                <code-set>
                    <code-block language="java"><![CDATA[
                        Query query = database.getView("products").createQuery();
                        // we don't need the reduce here
                        query.setMapOnly(true);
                        QueryEnumerator result = query.run();
                        for (Iterator<QueryRow> it = result; it.hasNext(); ) {
                           QueryRow row = it.next();
                           String productName = (String) row.getValue();
                           Log.w("MYAPP", "Product named %s", productName);
                        }
                    ]]></code-block>              
                </code-set>
                <paragraph>First get the appropriate View, create a Query from it and then run the query. This is the simplest form.</paragraph>
                <paragraph>Than you can modify some parameters from the Query object. Here the result of the query will log the product from the oldest to the newest. What if you want the newest first? You can use the descending parameter:</paragraph>
                <unordered-list><list-item><strong>descending</strong>: If set to true, the keys will be returned in reverse order. (This also reverses the meanings of the startKey and endKey properties, since the query will now start at the highest keys and end at lower ones!)</list-item></unordered-list>
                <paragraph>Now we have all the products from the most to the least recent. This could be a lot of products. You don't want to get 10000 of them in a single query. How would you display all of them on a mobile device? Maybe you want to count them? Then that's why we have a reduce function. Instead let's limit the number of rows returned by the query thanks to the <strong>limit</strong> parameter:</paragraph>

                <unordered-list><list-item><strong>limit</strong>: If nonzero, this is the maximum number of rows that will be returned.</list-item></unordered-list>

                <paragraph>The next logical step when you have the first 10 newer products is to get the ten next newer products. To do this you can use the <strong>skip</strong> parameter. This is how you implement <em>pagination</em>:</paragraph>

                <unordered-list><list-item><strong>skip</strong>: If nonzero, this many rows will be skipped (starting from the startKey if any.)</list-item></unordered-list>

                <paragraph>The resulting code for the third page of a 10 row pagination would look like this:</paragraph>
                <code-set>
                    <code-block language="java"><![CDATA[
                        Query query = database.getView("products").createQuery();
                        // we don't need the reduce here
                        query.setMapOnly(true);
                        query.setDescending(true);
                        query.setLimit(10);
                        query.setSkip(20);
                        QueryEnumerator result = query.run();
                        for (Iterator<QueryRow> it = result; it.hasNext(); ) {
                           QueryRow row = it.next();
                           String productName = (String) row.getValue();
                           Log.w("MYAPP", "Product named %s", productName);
                        }
                    ]]></code-block>              
                </code-set>
                <paragraph>This pagination use case works nicely when you want to show all the products without any particular criteria. What if you want all the product created between this date and this other date? This is where the startKey and endKey parameters comes into play.</paragraph>
                <unordered-list><list-item><strong>startKey</strong>: the key to start at. The default value, null, means to start from the beginning.</list-item>
                <list-item><strong>endKey</strong>: the last key to return. The default value, null, means to continue to the end.</list-item></unordered-list>
                <paragraph>To get the 10 most recent product of all the product created between February 8, 2011(1297123200 in epoch timestamp) and May 21, 2014(1400630400 in epoch timestamp):</paragraph>
                <code-set>
                    <code-block language="java"><![CDATA[
                        Query query = database.getView("products").createQuery();
                        // we don't need the reduce here
                        query.setMapOnly(true);
                        query.setDescending(true);
                        query.setLimit(10);
                        query.setSkip(0);
                        query.setStartKey(1400630400);
                        query.setEndKey(1297123200);
                        QueryEnumerator result = query.run();
                        for (Iterator<QueryRow> it = result; it.hasNext(); ) {
                           QueryRow row = it.next();
                           String productName = (String) row.getValue();
                           Log.w("MYAPP", "Product named %s", productName);
                        }
                    ]]></code-block>              
                </code-set>
                <paragraph>While it's good to have pagination, it's better to know where it stops. Like how many pages do you have? For that we can use the reduce. All you have to do is set MapOnly to false. The result is still a QueryEnumerator but with only one row. It's value is what is returned by the reduce function.</paragraph>
                <code-set>
                    <code-block language="java"><![CDATA[
                        Query query = database.getView("products").createQuery();
                        query.setMapOnly(true);
                        QueryEnumerator result = query.run();
                        Integer total = (Integer) result.getRow(0).getValue();
                    ]]></code-block>              
                </code-set>
                <paragraph>If you are in a search with criteria use case, you don't want the total obviously. You only want the total of rows returned by said search. This will work automatically if you specify the start and end keys like this:</paragraph>
                <code-set>
                    <code-block language="java"><![CDATA[
                        Query query = database.getView("products").createQuery();
                        query.setMapOnly(true);
                        query.setStartKey(1400630400);
                        query.setEndKey(1297123200);
                        QueryEnumerator result = query.run();
                        Integer total = (Integer) result.getRow(0).getValue();
                    ]]></code-block>              
                </code-set>
                <paragraph>You will find more details on Couchbase Queries in the <a href="http://developer.couchbase.com/mobile/develop/guides/couchbase-lite/native-api/query/index.html">reference guide</a>.</paragraph>
            </body>
        </topic>
    </topics>
</article>
